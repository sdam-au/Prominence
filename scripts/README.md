# R scripts to calculate raster-wide prominence

ProminencePixels.R calculates a prominence raster out of a digital elevation model by running a moving square window through the input raster where the percentage of cells smaller than the middle one is calculated. Output is written to a raster file (GTiff) viewable in R or in ArcMap. The user needs to specify  the name of the output file ("name.tif") and the size of moving window in the number of cells/pixels. The size of the moving window needs to be an odd number as the calculation requires the same number of cells to the left and right of the central cell. Edge effects will increase with the size of the moving window and should be accounted of in the final interpretation.
This function is best for arbitrary rasters which are not projected and have no map units, or where the user does not know the units.


ProminenceRadius.R calculates a prominence raster out of a digital elevation model by running a moving square window through the input raster where the percentage of cells smaller than the middle one is calculated. This function produces a viewable plot, but to write the resulting raster to file (GTiff viewable in R or in ArcMap), one must run the following script below the function (it is not embedded in the function as in ProminencePixels.R).
User needs to specify size of moving window by setting the radius in meters (or other relevant map units). The moving window side will be twice the length of radius. The radius needs to be an odd number as the calculation requires the same number of cells to the left and right of the central cell. Edge effects will increase with the size of the moving window and should be accounted of in the final interpretation.
This function is suitable when the user needs to calculate prominence of a spot in relation to a specific map distance.

Focal_Kaz.R script demonstrates how f.prom() function can be used inside a focal() function from raster package that delivers neighborhood statistics by allowing user to specify the size of the window in which an arbitrary function can be run. This approach is minutes faster than the previous two implementations which implement radius or pixel neighborhood, but one needs to be able to specify the neighborhood in rows and columns (and be able to infer the size of the neighborhood from raster data) 
